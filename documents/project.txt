プロジェクトノート

[目的]
	Parallelized Template手法を確立する（主にIRからのテンプレートマッチングと
	それによる速度向上)

[実装言語]
	MinPy(Minimized-Python):
		class:なし
		変数:NumberとString,及びListのみ
		関数: defのみサポート。ファンクタとして用いることで
					関数変数として使えるようにする
		組み込み関数: mapとfilterを実装し、ここを並列化の肝としたい
		
[構成]
	C++ & LLVM & Python-C APIを用いる。
	スタートアップでPython-Cのcompilerモジュールを用いてASTを生産。
	（インタプリタ実行そのものなのでこれによって実行が
	従来手法より遅くなることはない）
	そしてそのASTを基にしてLLVMーIRを生成。Optした後に
	そこからテンプレートマッチングを行う。
	そこでひっかかった箇所をLLVMーIRの関数呼び出しめ異例に置き換える。

	利用するすべての変数は（インタプリタレベルでの）
	グローバルな空間に置いておき、Parallelized Primitiveの仕組みを遵守する。
	(その為にグローバルなKey-Valueストアを用意しておく）


[Memo/idea]
  * インタプリタ/JITの研究として見ておくべき事
      * オーバーヘッド(Parallelized Primitiveで解決できる)
      * 実行時間(当然ながら)
      // * コンパイルする場所としない場所の判定
      * 並列化すべきかどうかの判定
      * 実行時コンパイル時間を節約する為のコンパイル手法
        (この方法だったら○○だからコンパイル時間もさほどかからない、など)
      * 並列化の方法

  for文(foreach)のイテレーションで、イテレータが上書きされないこと
  (言語仕様上は上書きされることがあるがそんな事をしてはバグにしかならない）
  を利用して並列化できる？
    アンロール->コンパイル->そのコードを並列実行する為のメタなテンプレート
    を利用しコンパイルしたものを並列実行.
  この方法は、従来のテンプレートとは別の方法として考える事ができる。
  従来までのテンプレートはコンテキスト単位のものだったが、
  これはfor文の中身をコンパイルし、それを現在の変数を受け取る関数
  として変形し、その関数ポインタを含んだものをジョブとして
  定義してそれを並列で実行する為の（予めインタプリタ側で用意しておいた）
  並列実行関数で実行する。

  また、並列実行の際にコンフリクトが起きないように、
  そのループの外側のスコープにあるリストや変数、
  及びそのループ自体のイテレータがリストであった場合に,
  それらのデータの変更を各自のジョブで用意しそれに書き込み、
  ジョブの終了に伴い元々の変数にかき戻す方法を考える。





